type Query {
    # The Single Master Entry Point for Persons
    searchPeople(
        text: String, 
        filter: PersonFilterInput, 
        page: Int, 
        size: Int, 
        sort: [PersonSort]
    ): PersonConnection

    personById(id: ID!): Person
    
    # Publication Queries
    publications: [Publication]
    searchPublications(text: String!): [Publication]
}

type Publication {
    id: ID!
    title: String
    journalName: String
    publicationDate: String
    status: String
    doi: String
    authors: [PublicationAuthor]
}

type PublicationAuthor {
    id: ID!
    rank: Int
    isCorresponding: Boolean
    affiliationAtTimeOfPublication: String
    person: Person
}

input PersonFilterInput {
    id: StringFilter
    and: [PersonFilterInput]
    or: [PersonFilterInput]
    not: PersonFilterInput
    
    # Fields
    name: StringFilter
    email: StringFilter
    age: IntFilter
    salary: FloatFilter
    birthDate: DateFilter
    isActive: BooleanFilter
    
    # Nested Fields (Simplified for this layer, handled by builder)
    addresses_country: StringFilter
    addresses_state: StringFilter
    addresses_city: StringFilter
}

input StringFilter {
    eq: String
    contains: String
    startsWith: String
    endsWith: String
    in: [String]
}

input IntFilter {
    eq: Int
    gt: Int
    lt: Int
    gte: Int
    lte: Int
}

input FloatFilter {
    eq: Float
    gt: Float
    lt: Float
}

input DateFilter {
    eq: String
    gt: String
    lt: String
    gte: String
    lte: String
}

input BooleanFilter {
    eq: Boolean
}

input PersonSort {
    field: SortField!
    direction: SortDirection
}

enum SortField {
    NAME
    AGE
    SALARY
    BIRTH_DATE
}

enum SortDirection {
    ASC
    DESC
}

type PersonConnection {
    results: [Person]
    facets: PersonFacets
    stats: PersonStats
    totalElements: Int
    totalPages: Int
}

type PersonStats {
    salary: NumericStats
    age: NumericStats
}

type NumericStats {
    min: Float
    max: Float
    avg: Float
    sum: Float
    count: Int
}

type PersonFacets {
    byActive: [FacetBucket]
    byCountry: [FacetBucket]
    byState: [FacetBucket]
}

type FacetBucket {
    value: String
    count: Int
}

type NameFacet {
    value: String
    count: Int
}

type Mutation {
    createPerson(name: String!, age: Int!, email: String, phoneNumber: String, birthDate: String, isActive: Boolean, salary: Float): Person
    addAddress(personId: ID!, street: String!, city: String!, state: String!, zip: String!, country: String, isPrimary: Boolean): Person
    
    # Publication Mutations
    createPublication(title: String!, journalName: String!, publicationDate: String, status: String, doi: String): Publication
    addAuthorToPublication(publicationId: ID!, personId: ID!, rank: Int!, isCorresponding: Boolean, affiliation: String): Publication
}

type Person {
    id: ID!
    name: String!
    age: Int!
    email: String
    phoneNumber: String
    birthDate: String
    isActive: Boolean
    salary: Float
    addresses: [Address]
}

type Address {
    id: ID!

    street: String
    city: String
    state: String
    zip: String
    country: String
    isPrimary: Boolean
}
