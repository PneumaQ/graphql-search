scalar JSON

type Query {
    # The Universal Search Entry Point for Products
    searchProducts(
        text: String, 
        filter: [SearchCondition], 
        facetKeys: [String], 
        statsKeys: [String],
        sort: [ProductSort],
        page: Int,
        size: Int
    ): ProductSearchResult

    # Tabular "Join" View: One row per Review
    searchProductReviewTable(text: String): [ProductReviewRow]
}

type ProductReviewRow {
    # From Product
    productName: String
    sku: String
    brandName: String
    
    # From Review
    author: String
    comment: String
    rating: Int
}

input SearchCondition {
    field: String
    # String Operators
    eq: String
    contains: String
    startsWith: String
    in: [String]
    
    # Numeric/Date Operators
    gt: Float
    lt: Float
    gte: Float
    lte: Float

    # Recursive Logic
    and: [SearchCondition]
    or: [SearchCondition]
    not: SearchCondition
}

input ProductSort {
    field: String!
    direction: SortDirection
}

enum SortDirection {
    ASC
    DESC
}

type ProductSearchResult {
    results: [Product]
    facets: JSON      # Clean Map: { "category": { "Electronics": 5, "Clothing": 2 } }
    stats: JSON       # Clean Map: { "price": { "min": 10, "max": 500, "avg": 45 }, "rating": { ... } }
    totalElements: Int
    totalPages: Int
}

type Product {
    id: ID!
    name: String
    sku: String
    category: String
    price: Float
    brand: Lookup
    custom_attributes: JSON
    reviews: [Review]
}

type Lookup {
    id: ID!
    name: String
    description: String
    lookupType: String
}

type Review {
    id: ID!
    author: String
    comment: String
    rating: Int
}

type Mutation {
    # Keep mutations for data setup if needed, but we will focus on search in UI
    createProduct(name: String!, sku: String!, category: String, price: Float, custom_attributes: [ProductAttributeInput]): Product
    addReview(productId: ID!, author: String, comment: String, rating: Int): Product
}

input ProductAttributeInput {
    key: String!
    value: String!
}