scalar JSON

type Query {
    # Metadata Discovery (New!)
    metadata(entityName: String!): [PropertyMetadata]

    # The Universal Search Entry Point for Products
    searchProducts(
        text: String, 
        filter: [SearchConditionInput], 
        facetKeys: [String], 
        statsKeys: [String],
        sort: [ProductSortInput],
        page: Int,
        size: Int
    ): ProductSearchResult

    # The Universal Search Entry Point for People (New!)
    searchPeople(
        text: String,
        filter: [SearchConditionInput],
        facetKeys: [String],
        statsKeys: [String],
        sort: [PersonSortInput],
        page: Int,
        size: Int
    ): PersonSearchResult

    # Tabular "Join" View: One row per Review
    searchProductReviewTable(text: String): [ProductReviewRow]
    
    # Publication Search
    searchPublications(
        text: String,
        filter: PublicationFilterInput,
        sort: [PublicationSortInput],
        page: Int,
        size: Int
    ): PublicationSearchResult
    
    publications: [Publication]
}

type PropertyMetadata {
    propertyName: String
    dataType: String
    dotPath: String
}

type PersonSearchResult {
    results: [Person]
    facets: JSON
    stats: JSON
    totalElements: Int
    totalPages: Int
}

type Person {
    id: ID!
    name: String
    email: String
    age: Int
    addresses: [Address]
}

type Address {
    id: ID!
    street: String
    city: String
    country: String
}

type ProductReviewRow {
    # From Product
    productName: String
    sku: String
    brandName: String
    
    # From Review
    author: String
    comment: String
    rating: Int
}

input SearchConditionInput {
    field: String
    # String Operators
    eq: String
    contains: String
    startsWith: String
    in: [String]
    
    # Numeric/Date Operators
    gt: Float
    lt: Float
    gte: Float
    lte: Float

    # Recursive Logic
    and: [SearchConditionInput]
    or: [SearchConditionInput]
    not: SearchConditionInput
}

input ProductSortInput {
    field: String!
    direction: SortDirection
}

input PersonSortInput {
    field: String!
    direction: SortDirection
}

input PublicationSortInput {
    field: PublicationSortField!
    direction: SortDirection
}

enum PublicationSortField {
    TITLE
    JOURNAL_NAME
    PUBLICATION_DATE
    STATUS
}

enum SortDirection {
    ASC
    DESC
}

type ProductSearchResult {
    results: [Product]
    facets: JSON
    stats: JSON
    totalElements: Int
    totalPages: Int
}

type Product {
    id: ID!
    name: String
    sku: String
    category: String
    price: Float
    brand: Lookup
    custom_attributes: JSON
    reviews: [Review]
}

type Lookup {
    id: ID!
    name: String
    description: String
    lookupType: String
}

type Review {
    id: ID!
    author: String
    comment: String
    rating: Int
}

type PublicationSearchResult {
    results: [Publication]
    statusCounts: JSON
    journalCounts: JSON
    totalElements: Int
    totalPages: Int
}

type Publication {
    id: ID!
    title: String
    journalName: String
    publicationDate: String
    status: String
    doi: String
    authors: [PublicationAuthor]
}

type PublicationAuthor {
    id: ID!
    person: Person
    rank: Int
    isCorresponding: Boolean
    affiliationAtTimeOfPublication: String
}

type Mutation {
    createPerson(input: CreatePersonInput!): Person
    updatePerson(input: UpdatePersonInput!): Person
    createProduct(name: String!, sku: String!, category: String, price: Float, custom_attributes: [ProductAttributeInput]): Product
    addReview(productId: ID!, author: String, comment: String, rating: Int): Product
}

input CreatePersonInput {
    name: String!
    email: String!
    age: Int
    addresses: [AddressInput]
}

input UpdatePersonInput {
    id: ID!
    name: String
    email: String
    age: Int
    addresses: [AddressInput]
}

input AddressInput {
    id: ID
    street: String
    city: String
    country: String
}

input ProductAttributeInput {
    key: String!
    value: String!
}

input PersonFilterInput {
    name: String
    age: Int
    email: String
    and: [PersonFilterInput]
    or: [PersonFilterInput]
    not: PersonFilterInput
}

input PublicationFilterInput {
    title: String
    journalName: String
    status: String
    and: [PublicationFilterInput]
    or: [PublicationFilterInput]
    not: PublicationFilterInput
}
